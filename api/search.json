[{"id":"7e9c0ed522e9f463cbadca3b64226a03","title":"Elasticsearch的介绍与安装","content":"Elasticsearch是一个分布式的开源搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。Elasticsearch是在Lucene的基础上开发而成，由Elasticsearch N.V(即现在的Elastic)于2010年首次发布。Elasticsearch以其简单的REST风格的API、分布式特性、速度和可扩展性而闻名，是Elastic Stack的核心组件。\n\n什么是ELK？Elastic Stack通常被称为ELK Stack(代指Elasticsearch、LogStash和Kibana),Elastic Stack是适用于数据采集、充实、存储、分析和可视化的一组开源工具。目前Elastic Stack包括一系列丰富的轻量型数据采集代理，这些代理统称为Beats，可用来向Elasticsearch发送数据。\nLucene vs Solr vs Elasticsearch\n都使用倒排序索引\nLucene是一个类库，基于Java的全文搜索引擎。\nSolr基于Lucene构建的开源引擎，使用Java封装。\nES基于Lucene,高扩展性，支持PB级别的搜索。\n\n\n\n\n\n\n\n\n\n\n正排索引和倒排索引\n正排索引：文档ID作为索引，以文档内容作为记录。但是这样检索关键词的时候很费力，要一个文档一个文档的遍历一遍。\n\n倒排索引：将单词或记录作为索引，将文档ID作为记录，这样便可以方便地通过单词或记录查找到其所在的文档。\n\nElasticsearch安装\n下载Elasticsearch(点击进入Elasticsearch下载页)，选择Linux版本下载。\n\n上传到服务器，进入Elasticsearch的目录下\ntar -zxvf elasticsearch-7.4.2-linux-x86_64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;\n\n\n\n\n\n\n\n\n\n\nElasticsearch的目录结构：\nbin：可执行文件包括elasticsearch启动节点、elasticsearch-plugin安装插件。\nconfig：配置文件\njdk: Elasticsearch依赖的Java环境\nlib：依赖的类库\nlogs：日志文件\nmodules：和ES有关的模块\nplugins: ES的自定义插件\n\n进入Elasticsearch的解压目录内，创建data文件夹\ncd &#x2F;usr&#x2F;local&#x2F;elasticsearch-7.4.2&#x2F;\nmkdir data\n进入config目录进行配置，对elasticsearch.yml进行修改\ncd config&#x2F;\nvim elasticsearch.yml \n配置cluster.name，cluster.name为ES集群名称\ncluster.name: joker-elasticsearch\n配置node.name，node.name为当前ES节点名称\nnode.name: es-node1\n配置path.data和path.logs，path.data为ES数据源路径，path.logs为ES的log日志路径\n# Path to directory where to store the data (separate multiple       locations by comma):\n#\npath.data: &#x2F;usr&#x2F;local&#x2F;elasticsearch-7.4.2&#x2F;data\n#\n# Path to log files:\n#\npath.logs: &#x2F;usr&#x2F;local&#x2F;elasticsearch-7.4.2&#x2F;logs\n配置network.host，network.host为绑定ip地址\n# Set the bind address to a specific IP (IPv4 or IPv6):\nnetwork.host: 0.0.0.0\n配置luster.initial_master_nodes\ncluster.initial_master_nodes: [&quot;es-node1&quot;]\n\n\n\n\n\n\n\n\n\n\n修改jvm.options文件,可以配置ES的运行内存\n\n进入bin目录，启动Elasticsearch\ncd bin&#x2F;\n.&#x2F;elasticsearch -d\n\n\n\n\n\n\n\n\n\n\n在启动Elasticsearch的时候需注意一下几点：\n\n不能以root用户启动Elasticsearch，否则会报错。\n\n启动Elasticsearch报错max virtual memory areas vm.max_map_count    [65530] is too low, increase to at least [262144],\n\n解决方案：修改sysctl.conf文件\n\nvim &#x2F;etc&#x2F;sysctl.conf\n\n\n修改vm.max_map_count的内存大小\n\nvm.max_map_count&#x3D;262145\n\n\n使用sysctl -p命令刷新配置\n\nsysctl -p\n\n以上就是Elasticsearch的基本概念以及安装，不同版本可能有细微差别，如安装出现问题可参考官方文档解决。\n","slug":"Elasticsearch的介绍与安装","date":"2022-01-18T03:05:24.000Z","categories_index":"ELK","tags_index":"Elasticsearch","author_index":"Joker"},{"id":"490a67515f99d8181b0d3a14207f422b","title":"Kotlin中的伴生对象和静态方法","content":"在日常的开发中，我们经常使用静态变量和静态方法，在java开发中大家经常遇到，那么在kotlin中应该如何使用静态方法和静态对象呢？\njava中的静态方法public class JavaUtils &#123;\n    public static int sum(int a,int b) &#123;\n        return a + b;\n    &#125;\n\n&#125;\n\nKotlin中的静态方法在kotlin中其实是不支持静态方法和静态成员的，但是kotlin支持全局函数和变量。在学习kotlin的过程中，发现了几种方法可以实现kotlin中的静态方法\n\n静态类：使用object关键字，类中的所有的方法都是静态方法。\nobject Utils &#123;\n    fun sum(a:Int,b:Int):Int &#x3D; a+ b\n    const val FLAG &#x3D; true\n&#125;\n\n使用方式：\nfun main(args: Array&lt;String&gt;) &#123;\n    Utils.sum(1,2)\n    Utils.FLAG\n&#125;\n\n在java中的使用方式：\npublic static void main(String[] args) &#123;\n    Utils.INSTANCE.sum(1,2);\n&#125;\n\n如果我们在java中调用也想和在kotlin中调用方式一样，那么应该如何来写？其实很简单，只需要在kotlin中的静态方法或者静态成员上面添加注解 @JvmStatic  和 @JvmField即可\nobject Utils &#123;\n    @JvmStatic\n    fun sum(a:Int,b:Int):Int &#x3D; a+ b\n    @JvmField\n    var FLAG &#x3D; true\n&#125;\n\n那么在java中的调用方式就和kotlin中完全一致了\npublic static void main(String[] args) &#123;\n    Utils.sum(1,2);\n    Utils.FLAG &#x3D; false;\n&#125;\n\n\n\n\n\n\n\n\n\n\n注意object关键字的特点：\n只有一个实例的类(单例)\n不能自定义构造方法\n可以实现接口、继承父类\n本质上就是单例模式\n\n通过Kotlin中的伴生对象来实现\n在文章的开始说过，在Kotlin中并没有静态类和成员的概念，但是并不是的kotlin中不能实现类似相应的功能。我们可以通过kotlin中的伴生对象来实现，每个类都可以对应一个伴生对象，伴生对象的成员全局独一份，伴生对象的成员类似java中的静态成员。\nclass ManagerConstants &#123;\n    companion object &#123;\n        val isLogin &#x3D; false\n\n        fun sum(a:Int,b:Int):Int &#123;\n            return a + b\n        &#125;\n\n    &#125;\n&#125;\n\n使用方式：\nfun main(args: Array&lt;String&gt;) &#123;\n    ManagerConstants.sum(1,2)\n    ManagerConstants.isLogin\n&#125;\n\njava中的使用方式：\npublic static void main(String[] args) &#123;\n   ManagerConstants.Companion.sum(1,2);\n  ManagerConstants.Companion.isLogin();\n&#125;\n\n和静态类一样如果想要java和kotlin的使用方式一样，需要在kotlin类中的方法和变量上添加注解    @JvmStatic  和  @JvmField即可\nclass ManagerConstants &#123;\n    companion object &#123;\n        @JvmField\n        val isLogin &#x3D; false\n        @JvmStatic\n        fun sum(a:Int,b:Int):Int &#123;\n            return a + b\n        &#125;\n\n    &#125;\n&#125;\n\n那么在java中的使用方式：\npublic static void main(String[] args) &#123;\n   ManagerConstants.sum(1,2);\n   ManagerConstants.isLogin;\n&#125;\n使用包级函数和变量\nKotlin和Java及C#不同的是，可以在包里面直接声明函数。做法和类中是一样的。\n创建一个名为static.kt的文件，然后在文件中直接写方法和变量\n\n使用方式：\nfun main(args: Array&lt;String&gt;) &#123;\n    var intSum &#x3D; sum(1,2)\n    println(kotlinFlag)\n&#125;\n\n在java中的使用方式：\npublic static void main(String[] args) &#123;\n   StaticKt.sum(1,2);\n&#125;\n\n看到这里相信小伙伴对kotlin中的静态方法的写法已经有了基本的理解，最后需要注意的是，在kotlin中使用静态方法的场景建议使用包级函数、成员的方式来实现。\n","slug":"Kotlin中的伴生对象和静态方法","date":"2022-01-13T12:14:10.000Z","categories_index":"Android","tags_index":"Kotlin","author_index":"Joker"},{"id":"b9663f58f18133b35bfe243f3e916a80","title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n","slug":"hello-world","date":"2022-01-12T13:38:41.557Z","categories_index":"其他","tags_index":"","author_index":"Joker"}]