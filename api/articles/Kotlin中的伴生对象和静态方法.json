{"title":"Kotlin中的伴生对象和静态方法","uid":"490a67515f99d8181b0d3a14207f422b","slug":"Kotlin中的伴生对象和静态方法","date":"2022-01-13T12:14:10.000Z","updated":"2022-01-18T03:06:36.489Z","comments":true,"path":"api/articles/Kotlin中的伴生对象和静态方法.json","keywords":null,"cover":"/post/Kotlin中的伴生对象和静态方法/cover.jpeg","content":"<p>在日常的开发中，我们经常使用<strong>静态变量</strong>和<strong>静态方法</strong>，在java开发中大家经常遇到，那么在kotlin中应该如何使用静态方法和静态对象呢？</p>\n<h4 id=\"java中的静态方法\"><a href=\"#java中的静态方法\" class=\"headerlink\" title=\"java中的静态方法\"></a>java中的静态方法</h4><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class JavaUtils &#123;\n    public static int sum(int a,int b) &#123;\n        return a + b;\n    &#125;\n\n&#125;</code></pre>\n\n<h4 id=\"Kotlin中的静态方法\"><a href=\"#Kotlin中的静态方法\" class=\"headerlink\" title=\"Kotlin中的静态方法\"></a>Kotlin中的静态方法</h4><p>在kotlin中其实是不支持静态方法和静态成员的，但是kotlin支持全局函数和变量。在学习kotlin的过程中，发现了几种方法可以实现kotlin中的静态方法</p>\n<ul>\n<li><p><strong>静态类</strong>：使用object关键字，类中的所有的方法都是静态方法。</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">object Utils &#123;\n    fun sum(a:Int,b:Int):Int &#x3D; a+ b\n    const val FLAG &#x3D; true\n&#125;</code></pre>\n\n<p>使用方式：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">fun main(args: Array&lt;String&gt;) &#123;\n    Utils.sum(1,2)\n    Utils.FLAG\n&#125;</code></pre>\n\n<p>在java中的使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Utils.INSTANCE.sum(1,2);\n&#125;</code></pre>\n\n<p>如果我们在java中调用也想和在kotlin中调用方式一样，那么应该如何来写？其实很简单，只需要在kotlin中的静态方法或者静态成员上面添加注解 <strong>@JvmStatic</strong>  和 <strong>@JvmField</strong>即可</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">object Utils &#123;\n    @JvmStatic\n    fun sum(a:Int,b:Int):Int &#x3D; a+ b\n    @JvmField\n    var FLAG &#x3D; true\n&#125;</code></pre>\n\n<p>那么在java中的调用方式就和kotlin中完全一致了</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    Utils.sum(1,2);\n    Utils.FLAG &#x3D; false;\n&#125;</code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>注意object关键字的特点</strong>：</p>\n<p><strong>只有一个实例的类(单例)</strong></p>\n<p><strong>不能自定义构造方法</strong></p>\n<p><strong>可以实现接口、继承父类</strong></p>\n<p><strong>本质上就是单例模式</strong></p></blockquote>\n</li>\n<li><p><strong>通过Kotlin中的伴生对象来实现</strong></p>\n<p>在文章的开始说过，在Kotlin中并没有静态类和成员的概念，但是并不是的kotlin中不能实现类似相应的功能。我们可以通过kotlin中的伴生对象来实现，每个类都可以对应一个伴生对象，伴生对象的成员全局独一份，<strong>伴生对象的成员类似java中的静态成员</strong>。</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">class ManagerConstants &#123;\n    companion object &#123;\n        val isLogin &#x3D; false\n\n        fun sum(a:Int,b:Int):Int &#123;\n            return a + b\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n\n<p>使用方式：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">fun main(args: Array&lt;String&gt;) &#123;\n    ManagerConstants.sum(1,2)\n    ManagerConstants.isLogin\n&#125;</code></pre>\n\n<p>java中的使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n   ManagerConstants.Companion.sum(1,2);\n  ManagerConstants.Companion.isLogin();\n&#125;</code></pre>\n\n<p>和静态类一样如果想要java和kotlin的使用方式一样，需要在kotlin类中的方法和变量上添加注解    <strong>@JvmStatic</strong>  和  <strong>@JvmField</strong>即可</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">class ManagerConstants &#123;\n    companion object &#123;\n        @JvmField\n        val isLogin &#x3D; false\n        @JvmStatic\n        fun sum(a:Int,b:Int):Int &#123;\n            return a + b\n        &#125;\n\n    &#125;\n&#125;</code></pre>\n\n<p>那么在java中的使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n   ManagerConstants.sum(1,2);\n   ManagerConstants.isLogin;\n&#125;</code></pre></li>\n<li><p><strong>使用包级函数和变量</strong></p>\n<p>Kotlin和Java及C#不同的是，可以在包里面直接声明函数。做法和类中是一样的。</p>\n<p>创建一个名为static.kt的文件，然后在文件中直接写方法和变量</p>\n<p><img src=\"/post/Kotlin%E4%B8%AD%E7%9A%84%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/image1.png\" alt=\"包级函数\"></p>\n<p>使用方式：</p>\n<pre class=\"line-numbers language-kotlin\" data-language=\"kotlin\"><code class=\"language-kotlin\">fun main(args: Array&lt;String&gt;) &#123;\n    var intSum &#x3D; sum(1,2)\n    println(kotlinFlag)\n&#125;</code></pre>\n\n<p>在java中的使用方式：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n   StaticKt.sum(1,2);\n&#125;</code></pre></li>\n</ul>\n<p>看到这里相信小伙伴对kotlin中的静态方法的写法已经有了基本的理解，最后需要注意的是，<strong>在kotlin中使用静态方法的场景建议使用包级函数、成员的方式来实现</strong>。</p>\n","text":"在日常的开发中，我们经常使用静态变量和静态方法，在java开发中大家经常遇到，那么在kotlin中应该如何使用静态方法和静态对象呢？ java中的静态方法public class JavaUtils &#123; public static int sum(int a,int b...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"Android","slug":"Android","count":1,"path":"api/categories/Android.json"}],"tags":[{"name":"Kotlin","slug":"Kotlin","count":1,"path":"api/tags/Kotlin.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#java%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">java中的静态方法</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#Kotlin%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Kotlin中的静态方法</span></a></li></ol>","author":{"name":"Joker","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它<br>即刻开始,从现在开始<br>Just Do It！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"Elasticsearch的介绍与安装","uid":"7e9c0ed522e9f463cbadca3b64226a03","slug":"Elasticsearch的介绍与安装","date":"2022-01-18T03:05:24.000Z","updated":"2022-01-18T08:30:45.349Z","comments":true,"path":"api/articles/Elasticsearch的介绍与安装.json","keywords":null,"cover":"/post/Elasticsearch的介绍与安装/cover.jpeg","text":"Elasticsearch是一个分布式的开源搜索和分析引擎，适用于所有类型的数据，包括文本、数字、地理空间、结构化和非结构化数据。Elasticsearch是在Lucene的基础上开发而成，由Elasticsearch N.V(即现在的Elastic)于2010年首次发布。Ela...","link":"","photos":[],"count_time":{"symbolsCount":"2.3k","symbolsTime":"2 mins."},"categories":[{"name":"ELK","slug":"ELK","count":3,"path":"api/categories/ELK.json"}],"tags":[{"name":"Elasticsearch","slug":"Elasticsearch","count":3,"path":"api/tags/Elasticsearch.json"}],"author":{"name":"Joker","slug":"blog-author","avatar":"/images/avatar.jpeg","link":"/","description":"世界上只有一种真正的英雄主义，就是认清了生活的真相后还依然热爱它<br>即刻开始,从现在开始<br>Just Do It！","socials":{"github":"","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{}}},"feature":true},"next_post":{}}