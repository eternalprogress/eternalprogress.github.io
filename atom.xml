<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://eternalprogress.github.io</id>
    <title>学习记录</title>
    <updated>2022-01-12T07:18:24.993Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://eternalprogress.github.io"/>
    <link rel="self" href="https://eternalprogress.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://eternalprogress.github.io/images/avatar.png</logo>
    <icon>https://eternalprogress.github.io/favicon.ico</icon>
    <rights>All rights reserved 2022, 学习记录</rights>
    <entry>
        <title type="html"><![CDATA[Markdown语法学习]]></title>
        <id>https://eternalprogress.github.io/post/markdown-yu-fa-xue-xi/</id>
        <link href="https://eternalprogress.github.io/post/markdown-yu-fa-xue-xi/">
        </link>
        <updated>2022-01-12T06:50:49.000Z</updated>
        <content type="html"><![CDATA[<h3 id="使用号标记">使用#号标记</h3>
<p>使用#号标记可标识1-6级标题，一级标记对应一个 <code>#</code> 号，二级标记对应两个 <code>#</code> 号，依次类推。</p>
<p><code># 一级标题</code></p>
<h1 id="一级标题">一级标题</h1>
<p><code>## 二级标题</code></p>
<h2 id="二级标题">二级标题</h2>
<p><code>### 三级标题</code></p>
<h3 id="三级标题">三级标题</h3>
<p><code>### 四级标题</code></p>
<h3 id="四级标题">四级标题</h3>
<p><code>#### 五级标题</code></p>
<h4 id="五级标题">五级标题</h4>
<p><code>###### 六级标题</code></p>
<h6 id="六级标题">六级标题</h6>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[一篇文章学会Kotlin中的伴生对象和静态方法]]></title>
        <id>https://eternalprogress.github.io/post/一篇文章学会Kotlin中的伴生对象和静态方法/</id>
        <link href="https://eternalprogress.github.io/post/一篇文章学会Kotlin中的伴生对象和静态方法/">
        </link>
        <updated>2022-01-11T16:00:00.000Z</updated>
        <summary type="html"><![CDATA[<p>在日常的开发中，我们经常使用<strong>静态变量</strong>和<strong>静态方法</strong>，在java开发中大家经常遇到，那么在kotlin中应该如何使用静态方法和静态对象呢？</p>
]]></summary>
        <content type="html"><![CDATA[<p>在日常的开发中，我们经常使用<strong>静态变量</strong>和<strong>静态方法</strong>，在java开发中大家经常遇到，那么在kotlin中应该如何使用静态方法和静态对象呢？</p>
<!-- more -->
<h4 id="java中的静态方法">java中的静态方法</h4>
<pre><code class="language-java">public class JavaUtils {
    public static int sum(int a,int b) {
        return a + b;
    }

}
</code></pre>
<h4 id="kotlin中的静态方法">Kotlin中的静态方法</h4>
<p>在kotlin中其实是不支持静态方法和静态成员的，但是kotlin支持全局函数和变量。在学习kotlin的过程中，发现了几种方法可以实现kotlin中的静态方法</p>
<ul>
<li>
<p><strong>静态类</strong>：使用object关键字，类中的所有的方法都是静态方法。</p>
<pre><code class="language-kotlin">object Utils {
    fun sum(a:Int,b:Int):Int = a+ b
    const val FLAG = true
}
</code></pre>
<p>使用方式：</p>
<pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;) {
    Utils.sum(1,2)
    Utils.FLAG
}
</code></pre>
<p>在java中的使用方式：</p>
<pre><code class="language-java">public static void main(String[] args) {
    Utils.INSTANCE.sum(1,2);
}
</code></pre>
<p>如果我们在java中调用也想和在kotlin中调用方式一样，那么应该如何来写？其实很简单，只需要在kotlin中的静态方法或者静态成员上面添加注解**@JvmStatic<strong>和</strong>@JvmField**即可</p>
<pre><code class="language-kotlin">object Utils {
    @JvmStatic
    fun sum(a:Int,b:Int):Int = a+ b
    @JvmField
    var FLAG = true
}
</code></pre>
<p>那么在java中的调用方式就和kotlin中完全一致了</p>
<pre><code class="language-java">public static void main(String[] args) {
    Utils.sum(1,2);
    Utils.FLAG = false;
}
</code></pre>
<blockquote>
<p><strong>注意object关键字的特点</strong>：</p>
<p><strong>只有一个实例的类(单例)</strong></p>
<p><strong>不能自定义构造方法</strong></p>
<p><strong>可以实现接口、继承父类</strong></p>
<p><strong>本质上就是单例模式</strong></p>
</blockquote>
</li>
<li>
<p><strong>通过Kotlin中的伴生对象来实现</strong></p>
<p>在文章的开始说过，在Kotlin中并没有静态类和成员的概念，但是并不是的kotlin中不能实现类似相应的功能。我们可以通过kotlin中的伴生对象来实现，每个类都可以对应一个伴生对象，伴生对象的成员全局独一份，<strong>伴生对象的成员类似java中的静态成员</strong>。</p>
<pre><code class="language-kotlin">class ManagerConstants {
    companion object {
        val isLogin = false

        fun sum(a:Int,b:Int):Int {
            return a + b
        }

    }
}
</code></pre>
<p>使用方式：</p>
<pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;) {
    ManagerConstants.sum(1,2)
    ManagerConstants.isLogin
}
</code></pre>
<p>java中的使用方式：</p>
<pre><code class="language-java">public static void main(String[] args) {
   ManagerConstants.Companion.sum(1,2);
  ManagerConstants.Companion.isLogin();
}
</code></pre>
<p>和静态类一样如果想要java和kotlin的使用方式一样，需要在kotlin类中的方法和变量上添加**@JvmStatic<strong>和</strong>@JvmField**即可</p>
<pre><code class="language-kotlin">class ManagerConstants {
    companion object {
        @JvmField
        val isLogin = false
        @JvmStatic
        fun sum(a:Int,b:Int):Int {
            return a + b
        }

    }
}
</code></pre>
<p>那么在java中的使用方式：</p>
<pre><code class="language-java">public static void main(String[] args) {
   ManagerConstants.sum(1,2);
   ManagerConstants.isLogin;
}
</code></pre>
</li>
<li>
<p><strong>使用包级函数和变量</strong></p>
<p>Kotlin和Java及C#不同的是，可以在包里面直接声明函数。做法和类中是一样的。</p>
<p>创建一个名为static.kt的文件，然后在文件中直接写方法和变量</p>
<figure data-type="image" tabindex="1"><img src="https://eternalprogress.github.io/post-images/112233.png" alt="包级函数" loading="lazy"></figure>
<p>使用方式：</p>
<pre><code class="language-kotlin">fun main(args: Array&lt;String&gt;) {
    var intSum = sum(1,2)
    println(kotlinFlag)
}
</code></pre>
<p>在java中的使用方式：</p>
<pre><code class="language-java">public static void main(String[] args) {
   StaticKt.sum(1,2);
}
</code></pre>
</li>
</ul>
<p>看到这里相信小伙伴对kotlin中的静态方法的写法已经有了基本的理解，最后需要注意的是，<strong>在kotlin中使用静态方法的场景建议使用包级函数、成员的方式来实现</strong>。</p>
]]></content>
    </entry>
</feed>